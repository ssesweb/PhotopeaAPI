# Photopea API 自动化与 ComfyUI 集成报告

本报告旨在为开发者提供一份详尽的指南，阐述如何利用 Photopea 的 API 实现高级图像编辑和 PSD 内容的自动化操作，并重点探讨与本地部署的 ComfyUI 实例进行无缝集成，以实现背景移除、图像扩展及其他生成式修改等 AI 驱动的任务。本指南将提供清晰、完整且可操作的说明，包括前端 JavaScript 和 Python 的实际代码示例，以促进复杂自动化图像处理工作流的开发。

## I. Photopea API 自动化简介

### 目的与文档范围

本报告旨在为开发者提供一份详尽的指南，阐述如何利用 Photopea 的 API 实现高级图像编辑和 PSD 内容的自动化操作。核心目标是与本地部署的 ComfyUI 实例进行无缝集成，从而利用其强大的 AI 能力执行背景移除、图像扩展及其他生成式修改等任务。本报告将提供逻辑清晰、方式完整的说明，涵盖前端 JavaScript 和 Python 的调用示例，以满足用户对修改图像、插入图像、导出图像、打开 PSD、修改 PSD 内容（图层、文字、插入文字、插入图像、替换图层图像、复制图层图像）以及使用外部插件（如调用 ComfyUI 进行抠图、扩图、图像修改）等具体需求。

### Photopea 自动化能力概述

Photopea 作为一款强大的基于网络的图像编辑器，通过其 API 提供了广泛的程序化控制能力，与 Adobe Photoshop 等专业桌面应用程序的功能高度兼容 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。这种兼容性使得开发者可以利用现有 Photoshop 脚本的知识和资源。Photopea 对多种文件格式提供强大支持，并以 PSD 作为其主要工作格式，确保图层、文本及其他可编辑元素在自动化过程中得以保留和访问 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。Photopea 的一个显著优势在于其“完全本地”的操作特性，即所有处理均直接在用户设备上利用其 CPU 和 GPU 完成。这种设计不仅保障了用户隐私，也确保了文件处理的快速性，因为文件数据从未离开用户设备 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

### 集成架构概览（Photopea、前端 JS、Python 后端、ComfyUI）

所提出的集成架构以客户端 Photopea 实例为核心，该实例嵌入在宿主网页的 `<iframe>` 中。这个宿主页面，作为“外部环境”（Outer Environment, OE），主要通过 `postMessage` API 与 Photopea 进行双向通信。一个关键的中间层是 Python 后端服务器。该后端负责接收来自前端的图像数据和命令，协调对本地 ComfyUI 实例的 API 调用，处理返回结果，最终将处理后的数据返回给前端。这种多层架构有效地连接了客户端 Photopea 与服务器端的 ComfyUI AI 能力，从而实现了结合 Photopea 精确编辑工具与 ComfyUI 先进生成式 AI 功能的复杂工作流。

## II. Photopea API 基础

### 在网页中嵌入 Photopea (iframe 集成)

Photopea 被设计为通过 HTML `<iframe>` 标签嵌入到网页中。这种嵌入方式创建了一个隔离的环境，允许“外部环境”（即父级网页）与 Photopea 建立通信 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`<iframe>` 的 `src` 属性可以在加载时动态配置，通过哈希符号 (`#STRING_VALUE`) 后传递初始参数。Photopea 会将此字符串值解码为一个 JSON 配置对象 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。这种机制非常适合设置初始状态，例如预加载特定文件或自定义用户界面。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

以下是嵌入 Photopea 并进行基本交互的前端 JavaScript 示例：

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

HTML

<!---->

<!---->

<!---->

<!---->

<!---->

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photopea Integration Demo</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: Arial, sans-serif; }
        #photopea-container { width: 100%; height: calc(100% - 50px); border: 1px solid #ccc; box-sizing: border-box; }
        #photopea-iframe { width: 100%; height: 100%; border: none; }
       .controls { padding: 10px; background-color: #f0f0f0; text-align: center; }
        button { padding: 8px 15px; margin: 0 5px; cursor: pointer; }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="loadPsd()">加载示例 PSD</button>
        <button onclick="exportPng()">导出当前为 PNG</button>
        <span id="status-message">准备就绪</span>
    </div>
    <div id="photopea-container">
        <iframe id="photopea-iframe" src="http://localhost:8887/#{}"></iframe>
    </div>

    <script>
        const photopeaIframe = document.getElementById('photopea-iframe');
        const statusMessage = document.getElementById('status-message');
        let photopeaWindow;
        let currentCallbackId = 0;
        const callbacks = {}; // 用于管理异步响应

        photopeaIframe.onload = () => {
            photopeaWindow = photopeaIframe.contentWindow;
            statusMessage.textContent = 'Photopea iframe 加载完成。';

            window.addEventListener('message', (event) => {
                if (event.source === photopeaWindow) {
                    console.log('来自 Photopea 的消息:', event.data);
                    if (event.data === 'done') {
                        statusMessage.textContent = 'Photopea 已准备就绪或命令已处理。';
                    } else if (event.data instanceof ArrayBuffer) {
                        statusMessage.textContent = '收到 Photopea 发送的 ArrayBuffer (二进制数据)。';
                        const blob = new Blob([event.data], { type: 'image/png' }); // 假设导出为 PNG
                        const url = URL.createObjectURL(blob);
                        console.log('二进制数据 URL:', url);
                        // 演示：在新标签页中打开
                        window.open(url, '_blank');
                        statusMessage.textContent = 'PNG 已导出并在新标签页中打开。';
                    } else if (typeof event.data === 'string') {
                        try {
                            const parsedData = JSON.parse(event.data);
                            if (parsedData.callbackId && callbacks) {
                                callbacks(parsedData.data);
                                delete callbacks;
                            } else {
                                statusMessage.textContent = `消息: ${event.data}`;
                            }
                        } catch (e) {
                            statusMessage.textContent = `消息: ${event.data}`;
                        }
                    }
                }
            });

            // Photopea 加载完成后发送初始脚本以确认准备就绪
            photopeaWindow.postMessage(`
                app.echoToOE("Photopea 已准备好接收命令!");
                // 如果需要，可以在此处设置 customIO 来重定义文件菜单操作
                // app.environment.customIO = {
                //     save: "app.echoToOE('在 Photopea 中点击了保存按钮!'); app.activeDocument.saveToOE('psd');"
                // };
            `, '*');
        };

        function sendScriptToPhotopea(script, callback = null) {
            const id = currentCallbackId++;
            if (callback) {
                callbacks[id] = callback;
                // 将脚本结果封装在 JSON 中，并通过 echoToOE 返回，包含回调 ID
                script = `var result = (function(){ ${script} })(); app.echoToOE(JSON.stringify({callbackId: ${id}, data: result}));`;
            }
            photopeaWindow.postMessage(script, '*');
            statusMessage.textContent = '正在向 Photopea 发送命令...';
        }

        function loadPsd() {
            const psdUrl = 'https://www.photopea.com/templates/template.psd'; // 示例 PSD URL
            sendScriptToPhotopea(`app.open("${psdUrl}");`);
            statusMessage.textContent = `正在从 ${psdUrl} 加载 PSD...`;
        }

        function exportPng() {
            sendScriptToPhotopea(`app.activeDocument.saveToOE("png");`);
            statusMessage.textContent = '正在导出当前文档为 PNG...';
        }
    </script>
</body>
</html>
```

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

### 数据传输与配置

#### 使用 URL 参数进行初始设置

URL 哈希参数 (`#STRING_VALUE`) 允许在 Photopea 首次加载时传递一个 JSON 对象。这个 JSON 对象经过 `encodeURIComponent()` 编码后，可以包含各种配置选项 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。关键参数包括 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`files`（用于初始加载文档的 URL 或 Data URI 数组）、`resources`（用于加载自定义渐变、画笔、字体）、`server`（用于定义一个后端端点，Photopea 会向其 POST 保存的文档），以及 `environment`（用于广泛的用户界面自定义，如语言、主题和面板可见性） <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

**示例 JSON 配置（在 URL 哈希中）：**

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

JSON

<!---->

<!---->

<!---->

<!---->

<!---->

```
{
    "files": ["https://www.mysite.com/images/design.psd"],
    "environment": {
        "lang": "zh",
        "vmode": 0,
        "customIO": {
            "save": "app.echoToOE('SaveRequested'); app.activeDocument.saveToOE('psd');"
        }
    }
}
```

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

*此 JSON 需要经过 `encodeURIComponent` 编码并附加到 `http://localhost:8887/#` 之后。*

#### 实时消息传递 (`postMessage`) 进行双向通信

`postMessage` API 是外部环境 (OE) 与 Photopea 之间动态、实时交互的基石。OE 可以向 Photopea 发送两种类型的数据：`String`（包含 Photopea 将执行的 JavaScript 脚本）或 `ArrayBuffer`（二进制文件数据，如 PSD、JPG 或 PNG） <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。当 Photopea 初始化并准备好接收命令时，它会发送“done”消息。在处理完消息后，Photopea 也会发送回“done”消息 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。更重要的是，Photopea 可以使用 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`app.activeDocument.saveToOE()` 或 `app.echoToOE()` 将 `ArrayBuffer`（导出的图像）或自定义 `String` 消息发送回 OE <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

这种能力，即动态发送脚本和二进制数据，并接收二进制数据和状态消息，使得 `postMessage` 成为构建交互式和自动化 Photopea 工作流的实际标准。这对于用户动态“传递参数”和“指导代码生成”的需求至关重要，因为它允许在初始加载之外进行持续的、事件驱动的交互。例如，`postMessage` 允许文件在用户计算机内部直接传输，而无需上传到公共服务器，这对于处理大文件（如 1GB 文件）尤其高效 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。通过这种方式，Photopea 可以被视为一个“模块”或“批处理器”，实现复杂的客户端侧图像处理任务。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

#### 处理二进制数据 (ArrayBuffer) 和 Base64 编码字符串

二进制文件，如 PSD、JPG 或 PNG，通过 `postMessage` 以 `ArrayBuffer` 对象的形式高效传输 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。这种方法确保了直接的二进制数据传输，开销最小。另一种方式是将二进制数据以 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`data URI / base64` 格式嵌入到脚本字符串中 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。虽然对于小型数据负载来说很方便，但 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`ArrayBuffer` 通常更推荐用于大型图像或 PSD 文件，因为它能减少编码/解码的开销，从而提供更好的性能。在涉及大量图像数据（如修改、插入、导出）的用户任务中，使用 `ArrayBuffer` 进行实际图像数据传输（发送到 Photopea 和从 Photopea 接收）是至关重要的实际建议，有助于保持响应速度并防止自动化工作流中的性能下降。

### 本地部署注意事项

#### 解决跨域资源共享 (CORS) 问题

Web 浏览器强制执行安全策略，特别是 CORS，它限制 Web 应用程序向来自不同源（域、协议或端口）的资源发出请求。为了让 Photopea（或嵌入页面）从您的本地服务器加载文件，或者让 Photopea 将数据保存到自定义服务器端点，服务器响应**必须**包含 `Access-Control-Allow-Origin: *` HTTP 头 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。这在本地开发环境中尤为关键，因为 Photopea 可能从 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`localhost:8887` 提供服务，而嵌入应用程序可能从不同的端口（例如 `localhost:3000`）提供服务，或者图像可能从另一个本地地址提供。对 CORS 的反复强调 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->表明，对于任何涉及外部文件访问或服务器端保存的本地 Photopea 设置而言，它都是一项 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

**强制性配置**。未能正确实现此头将不可避免地导致与安全相关的关键故障，从而阻止预期的通信和数据传输。

#### 配置 Photopea 进行本地服务器交互

通过 URL 哈希参数传递的初始 JSON 配置中的 `server` 参数可以定义特定的端点，当用户点击“文件 - 保存”时，Photopea 将使用 POST 请求将文档数据发送到这些端点 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。这对于传统的服务器端保存很有用。然而，对于由 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`postMessage` 驱动的高度程序化和自动化保存与加载操作，外部环境 (OE) 直接处理文件传输。这使得 `server` 参数对于 OE 作为协调器的自动化工作流而言不那么关键。`customIO` 环境参数提供了一个强大的机制，可以重新定义 Photopea 文件菜单操作（例如，“新建”、“打开”、“保存”）的默认行为，以执行自定义脚本。通过为这些操作分配自定义 JavaScript 脚本，开发者可以触发 `app.echoToOE` 或 `app.activeDocument.saveToOE` 将数据或消息发送回 OE 进行自定义处理 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

### 表 1: Photopea API URL 参数和 JSON 配置

该表作为开发者快速理解和应用通过 URL 参数进行 Photopea 初始配置的简洁、直接参考，具有重要价值。它作为程序化交互的第一步，用于设置 Photopea 环境。通过整合分散在 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->中的信息，它显著简化了理解 Photopea UI 自定义和预加载所需文件可用选项的过程。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

| 参数                      | 类型  | 描述                                                             | 相关参考                                                                                                                                                                                                                                                                                                                                                                                                       | 示例值（在 JSON 中）                                                                                   |
| ----------------------- | --- | -------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| `files`                 | 数组  | Photopea 启动时加载的文件 URL 或 Data URI 数组。                           | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->        | `["https://example.com/image.psd", "data:image/png;base64,..."]`                                |
| `resources`             | 数组  | 要加载的资源 URL 数组（渐变、画笔、字体）。                                       | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->        | `["https://example.com/myfont.otf"]`                                                            |
| `server`                | 对象  | 用于将文档保存回指定服务器的参数。Photopea 通过 POST 方法将二进制数据（JSON + 文件）发送到此 URL。 | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->        | `{"url": "http://yourserver.com/save-photopea", "format": "psd"}`                               |
| `environment`           | 对象  | 包含自定义 Photopea UI 和行为的参数对象。                                    | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----> | `{"lang": "zh", "vmode": 2, "customIO": {"save": "app.echoToOE('User clicked save');"}}`        |
| `environment.theme`     | 数字  | 设置 UI 主题 (0, 1, 2,...)。                                        | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->        | `0` (默认)                                                                                        |
| `environment.lang`      | 字符串 | 设置界面语言。                                                        | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->        | `"zh"` (中文)                                                                                     |
| `environment.vmode`     | 数字  | 设置视图模式 (0: 常规, 1: 面板折叠, 2: 隐藏所有面板)。                            | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->        | `2` (隐藏所有面板以获得更简洁的嵌入)                                                                           |
| `environment.customIO`  | 对象  | 重新定义 Photopea 文件菜单操作（例如，“新建”、“打开”、“保存”）的行为以执行自定义脚本。            | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----> | `{"open": "app.echoToOE('Open dialog shown');", "save": "app.activeDocument.saveToOE('psd');"}` |
| `environment.localsave` | 布尔值 | 启用/禁用 UI 中的“另存为 PSD”、“保存为 Web”和“在线发布”选项。                       | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->        | `false` (强制通过 API 保存)                                                                           |
| `environment.autosave`  | 数字  | 指定 Photopea 自动执行“文件 - 保存”的时间间隔（秒）。                             | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->        | `60` (每 60 秒自动保存)                                                                               |
| `environment.plugins`   | 对象  | 配置第三方插件或 API 密钥（例如，Dezgo 用于背景移除）。                              | <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----> | `{"dezgo": "YOUR_DEZGO_API_KEY"}`                                                               |

## III. Photopea 脚本实现高级图像与 PSD 操作

### Photopea JavaScript 脚本环境简介

Photopea 自动化的核心优势在于其强大的 JavaScript 脚本环境。该环境提供了一个与 Adobe Photoshop 脚本接口高度兼容的对象模型 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。这种兼容性是一个显著优势，因为它允许开发者利用来自庞大 Photoshop 脚本社区的现有知识和资源。脚本模型能够实现复杂图像编辑任务的强大自动化，包括对文档结构、单个图层及其内容的直接操作。全局 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`app` 对象是应用程序的入口点，而 `app.activeDocument` 则提供对当前打开文件及其属性的访问 。

### 通过 `postMessage` 执行脚本

脚本通过 `window.postMessage()` 方法从外部环境作为 `String` 消息传输到 Photopea 实例 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。Photopea 接收后，会在其沙盒环境中执行提供的 JavaScript 代码，从而实现对活动文档的程序化控制。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

Photopea 的脚本执行是异步的。对于诸如 `app.open()`（加载新文档）或 `saveToOE()`（导出数据）等操作，脚本仅启动该操作；它不会同步等待完成 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。因此，外部环境必须实现一种健壮的机制来监听来自 Photopea 的后续“done”消息或二进制数据消息 ( <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`ArrayBuffer`)，以确定操作何时完成以及结果何时可用 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。这要求在嵌入应用程序的 JavaScript 中使用回调函数、Promise 或 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`async/await` 模式，以确保正确的序列和数据处理。例如，在 Photopea 打开一个新文件后，外部环境不应立即发送下一个命令，而应等待 Photopea 发送“done”消息，表明文件已完全加载并准备好进行进一步操作 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。这种对异步通信模式的理解对于构建可靠和可预测的自动化工作流至关重要。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

### 核心文档和图像操作

#### 打开文档

文档可以在初始加载时通过 URL 哈希配置中的 `files` 参数打开 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。在 Photopea 脚本中， <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`app.open(url, as, asSmart)` 可以从 URL 加载图像 。对于本地文件，最有效的方法是直接通过 `postMessage` 将文件作为 `ArrayBuffer` 发送到 Photopea <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

#### 保存文档

`app.activeDocument.saveToOE("format")` 是导出当前活动文档的关键方法。它将文档导出为指定格式（例如，“psd”、“png”、“jpg:0.8”用于质量控制，“psd:true”用于最小化 PSD）并将生成的二进制数据作为 `ArrayBuffer` 通过 `postMessage` 发送回外部环境 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。Photopea UI 中默认的“文件 - 保存”操作可以使用 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`customIO` 环境参数重新定义，以触发一个自定义脚本，然后该脚本使用 `saveToOE` 将数据发送到 OE <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

#### 修改图像属性

`app.activeDocument.resizeImage(width, height, resolution, resampleMethod)` 方法允许调整整个图像的大小，包括其内容，以适应新的尺寸和分辨率 。`app.activeDocument.resizeCanvas(width, height, anchor)` 方法仅调整画布（文档边界）的大小，而不缩放现有内容。`anchor` 参数指定现有内容相对于新画布尺寸的定位方式 。

#### 导出图像为各种格式

如前所述，`app.activeDocument.saveToOE()` 是主要的导出方法。示例包括 `app.activeDocument.saveToOE("png")`、`app.activeDocument.saveToOE("jpg:0.8")`（用于 80% 质量的 JPG）和 `app.activeDocument.saveToOE("psd:true")`（用于生成最小化的 PSD 文件） 。

### 图层管理与内容编辑

#### 访问和遍历图层

`app.activeDocument.layers` 属性返回活动文档中所有图层的集合 。可以通过其数字索引（例如，`layers` 表示最顶层）访问单个图层，或者更稳健地通过其名称使用类似 `layers.getByName("LayerName")` 的方法（通过 Photoshop 兼容性推断） <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

#### 选择、创建、删除和复制图层

`app.activeDocument.activeLayer` 属性允许设置或检索当前活动（选中）的图层，这对于许多直接操作至关重要 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`app.activeDocument.artLayers.add()` 创建一个新的空像素图层并将其添加到文档中 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`layer.remove()` 从文档中删除特定图层 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`layer.duplicate(targetDocument)` 复制一个图层。如果提供了 `targetDocument`，则该图层被复制到该文档；否则，它在同一文档内复制 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

#### 修改文本图层

Photopea 的脚本环境允许对文本图层进行细粒度控制，这与 Photoshop 的 `TextItem` 对象类似 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。要修改文本图层，首先需要获取对该图层的引用，然后访问其 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`textItem` 属性。`textItem.contents` 属性用于读取或修改文本内容 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。此外， <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`TextItem` 还提供了修改文本样式和位置的属性，例如 `size`（字体大小）、`color`（文本颜色）、`position`（文本原点位置）和 `totalTextStyle`（一个包含所有样式参数的 JSON 字符串） <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。要插入新的文本图层，可以使用 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`app.activeDocument.artLayers.add()` 创建一个新图层，并将其 `kind` 属性设置为 `LayerKind.TEXT`，然后设置其 `textItem.contents` <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

**前端 JavaScript 示例（修改文本图层）：**

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

JavaScript

<!---->

<!---->

<!---->

<!---->

<!---->

```
// 假设 Photopea 已加载并准备就绪
function modifyTextLayer(layerName, newText, fontSize, textColorHex, x, y) {
    const script = `
        var doc = app.activeDocument;
        try {
            var textLayer = doc.layers.getByName("${layerName}");
            if (textLayer.kind === LayerKind.TEXT) {
                var textItem = textLayer.textItem;
                textItem.contents = "${newText}";
                textItem.size = ${fontSize}; // 字体大小
                // 设置颜色，Photopea 脚本颜色通常需要 RGB 值
                // 示例：红色
                var newColor = new SolidColor();
                newColor.rgb.hexValue = "${textColorHex}"; // 例如 "FF0000"
                textItem.color = newColor;
                textItem.position = [${x}, ${y}]; // 设置文本位置 [x, y]
                app.echoToOE("文本图层 '${layerName}' 已成功修改。");
            } else {
                app.echoToOE("错误: 图层 '${layerName}' 不是文本图层。");
            }
        } catch (e) {
            app.echoToOE("错误: 修改文本图层失败 - " + e.message);
        }
    `;
    sendScriptToPhotopea(script);
}

// 示例调用：
// modifyTextLayer("MyTitle", "Hello Photopea!", 48, "0000FF", 100, 100);
```

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

#### 插入图像到图层 / 替换图层图像

在 Photopea 中插入图像可以作为新图层，也可以替换现有图层的内容，特别是当现有图层是智能对象时 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。将图像作为新图层插入的最直接方法是使用 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`app.open()` 方法，并将其 `asSmart` 参数设置为 `true`，这会将图像作为智能对象插入到当前文档中 。

对于替换现有图层（尤其是智能对象）的内容，Photopea 兼容 Photoshop 的脚本模型，这意味着可以使用类似 `placedLayerReplaceContents` 的操作 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。将目标图层转换为智能对象是实现内容替换的关键步骤，因为智能对象旨在保留其原始内容，同时允许外部文件作为其内容进行更新 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

**前端 JavaScript 示例（插入图像作为新智能对象）：**

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

JavaScript

<!---->

<!---->

<!---->

<!---->

<!---->

```
// 假设 Photopea 已加载并准备就绪
function insertImageAsSmartObject(imageUrl, x, y, width, height) {
    const script = `
        var doc = app.activeDocument;
        app.open("${imageUrl}", null, true); // 打开图像作为智能对象
        // 新打开的智能对象会成为 activeDocument.activeLayer
        var newLayer = app.activeDocument.activeLayer;
        // 调整新插入智能对象的位置和大小
        // 注意：Photopea 的 translate 和 resize 方法可能需要更复杂的计算来保持比例或精确放置
        // 这里只是一个简化示例，实际应用中可能需要根据图像原始尺寸和目标尺寸进行计算
        newLayer.translate(${x}, ${y}); // 移动到指定位置
        // newLayer.resize(width, height, AnchorPosition.TOPLEFT); // 调整大小，可能需要更精细控制
        app.echoToOE("图像已作为智能对象插入。");
    `;
    sendScriptToPhotopea(script);
}

// 示例调用：
// insertImageAsSmartObject("https://example.com/new_image.png", 50, 50, 200, 150);
```

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

**前端 JavaScript 示例（替换智能对象内容）：**

要替换智能对象的内容，通常需要一个更复杂的脚本，它会模拟 Photoshop 中的操作。由于 Photopea 脚本与 Photoshop 脚本的兼容性，以下是一个概念性的方法，它需要一个智能对象图层的名称和一个新图像的 URL 或 Base64 数据。

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

JavaScript

<!---->

<!---->

<!---->

<!---->

<!---->

```
// 假设 Photopea 已加载并准备就绪，且目标图层是一个智能对象
function replaceSmartObjectContent(smartObjectLayerName, newImageUrlOrBase64) {
    const script = `
        var doc = app.activeDocument;
        try {
            var smartObjectLayer = doc.layers.getByName("${smartObjectLayerName}");
            if (smartObjectLayer.kind === LayerKind.SMARTOBJECT) {
                // Photopea 脚本中替换智能对象内容的直接 API 调用可能与 Photoshop 略有不同
                // 但通常可以通过以下方式实现：
                // 1. 选中智能对象图层
                doc.activeLayer = smartObjectLayer;

                // 2. 模拟“替换内容”操作。这通常涉及到 ActionDescriptor
                // Photopea 对 ActionDescriptor 的支持程度可能需要测试
                // 或者，更直接的方式是删除旧的智能对象，并用新的内容创建一个新的智能对象
                // 但为了保持智能对象特性，通常是更新其内部内容。
                // 鉴于 Photopea 强调与 Photoshop 脚本的兼容性，理论上以下 ActionDescriptor 模式应能工作：
                var idplacedLayerReplaceContents = stringIDToTypeID("placedLayerReplaceContents");
                var desc = new ActionDescriptor();
                // 如果是 URL，Photopea 内部会处理下载
                // 如果是 Base64，需要将其转换为文件或 Photopea 可识别的格式
                desc.putPath(charIDToTypeID("null"), new File("${newImageUrlOrBase64}")); // 假设 Photopea 可以直接处理 URL 或本地路径
                executeAction(idplacedLayerReplaceContents, desc, DialogModes.NO);

                app.echoToOE("智能对象图层 '${smartObjectLayerName}' 的内容已替换。");
            } else {
                app.echoToOE("错误: 图层 '${smartObjectLayerName}' 不是智能对象图层。");
            }
        } catch (e) {
            app.echoToOE("错误: 替换智能对象内容失败 - " + e.message);
        }
    `;
    sendScriptToPhotopea(script);
}

// 示例调用：
// replaceSmartObjectContent("ProductImageSO", "https://example.com/updated_product.jpg");
// 或者使用 Base64 数据 URI:
// replaceSmartObjectContent("ProductImageSO", "data:image/png;base64,iVBORw0KGgoAAAAN...");
```

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

#### 复制图层

图层可以通过 `layer.duplicate()` 方法进行复制 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。该方法可以仅在当前文档中复制图层，也可以指定目标文档，从而实现图层在不同文档之间的复制 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

**前端 JavaScript 示例（复制图层）：**

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

JavaScript

<!---->

<!---->

<!---->

<!---->

<!---->

```
// 假设 Photopea 已加载并准备就绪
function duplicateLayer(layerName, newLayerName = null) {
    const script = `
        var doc = app.activeDocument;
        try {
            var targetLayer = doc.layers.getByName("${layerName}");
            var duplicatedLayer = targetLayer.duplicate(); // 在当前文档中复制
            if ("${newLayerName}") {
                duplicatedLayer.name = "${newLayerName}"; // 重命名复制的图层
            }
            app.echoToOE("图层 '${layerName}' 已复制。");
        } catch (e) {
            app.echoToOE("错误: 复制图层失败 - " + e.message);
        }
    `;
    sendScriptToPhotopea(script);
}

// 示例调用：
// duplicateLayer("Background", "Background_Copy");
```

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

## IV. 插件集成与 ComfyUI 交互

### Photopea 插件机制

Photopea 支持通过 `environment` 配置中的 `plugins` 参数进行第三方插件集成 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。例如，它可以配置 Dezgo 的 API 密钥以实现背景移除功能 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。然而，这种内置的插件机制主要针对 Photopea 内部预设的特定服务。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

### 集成外部工具 (ComfyUI)

用户需求中明确指出希望通过现有接口调用外部工具，特别是本地服务器上运行的 ComfyUI 服务。由于 Photopea 的直接插件系统可能无法直接调用任意外部 HTTP 服务，因此需要一种更通用的集成方法。为此，我们采用以下架构：前端 Photopea 实例通过 `postMessage` 将图像数据发送到 Python 后端，Python 后端作为中间件，负责与本地 ComfyUI 服务进行通信。

**工作流程：**

1. **Photopea 导出数据：** Photopea 使用 `app.activeDocument.saveToOE()` 方法将当前文档或特定图层的图像数据作为 `ArrayBuffer` 导出到前端（外部环境）。

2. **前端发送数据到后端：** 前端 JavaScript 通过 `fetch` 或 XMLHttpRequest 将接收到的 `ArrayBuffer` 数据发送到 Python 后端服务器的某个 API 端点（例如，通过 POST 请求）。

3. **Python 后端与 ComfyUI 交互：** Python 后端接收到图像数据后，将其上传到 ComfyUI，并触发 ComfyUI 工作流。

4. **ComfyUI 处理并返回结果：** ComfyUI 处理图像，生成结果，Python 后端从 ComfyUI 获取处理后的图像。

5. **后端发送结果到前端：** Python 后端将 ComfyUI 处理后的图像数据发送回前端。

6. **前端将结果导入 Photopea：** 前端接收到处理后的图像数据后，再通过 `postMessage` 将其作为 `ArrayBuffer` 发送回 Photopea，Photopea 可以将其作为新图层插入或替换现有图层。

### ComfyUI API 基础

ComfyUI 提供了一套 RESTful API，允许程序化地与工作流引擎交互 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。用户已在本地部署 ComfyUI 于 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

`http://192.168.110.13:8188/`。

**关键端点：**

* `/prompt` (POST): 用于将工作流排队等待执行 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

* `/upload/{image_type}` (POST): 用于上传输入图像或蒙版到 ComfyUI 服务器 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  `image_type` 可以是 `image` 或 `mask`。

* `/history/{prompt_id}` (GET): 用于检索给定提示的执行结果 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

* `/view` (GET): 用于获取生成的图像文件 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

**工作流 JSON：**

与 ComfyUI API 交互的核心是工作流的 JSON 结构，即 `workflow_api.json` 文件。这个文件定义了整个生成管道，包括所有节点（如模型加载、采样、编码）及其连接 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。可以通过在 ComfyUI 设置中启用开发模式选项，然后使用“保存 (API 格式)”按钮从 ComfyUI 界面导出此 JSON 文件 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

**输入/输出处理：**

* **注入输入：** 可以通过修改 `workflow_api.json` 中的相应节点来动态更新用户输入，例如设置文本提示、随机种子或指定输入图像的文件名 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。对于图像输入，需要先使用 <!---->  <!----><!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  `/upload` 端点将图像上传到 ComfyUI 服务器，然后在工作流 JSON 中引用其文件名 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

* **获取输出：** ComfyUI 工作流通常包含“Save Image”节点，会将结果保存到输出文件夹。通过 `/history/{prompt_id}` 获取执行历史，可以找到生成图像的文件名和子文件夹信息，然后使用 `/view` 端点下载这些图像 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

### Python 示例（ComfyUI 集成）

以下 Python 代码示例演示了如何通过后端服务与 ComfyUI 交互，以实现图像处理任务，例如背景移除或图像修改。

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

Python

<!---->

<!---->

<!---->

<!---->

<!---->

```
import requests
import json
import time
import base64
from io import BytesIO

# ComfyUI 服务器地址
COMFYUI_SERVER_ADDRESS = "http://192.168.110.13:8188"
# 假设的 ComfyUI 工作流 JSON 文件路径 (需要用户从 ComfyUI 导出)
# 例如，一个用于背景移除的工作流 JSON
COMFYUI_WORKFLOW_FILE = "workflow_remove_background.json"

def load_workflow(file_path):
    """加载 ComfyUI 工作流 JSON 文件"""
    with open(file_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def upload_image_to_comfyui(image_data, filename, folder_type="input"):
    """上传图像到 ComfyUI 服务器"""
    url = f"{COMFYUI_SERVER_ADDRESS}/upload/image"
    files = {'image': (filename, image_data, 'image/png')} # 假设为 PNG
    data = {"type": folder_type, "overwrite": "true"}
    response = requests.post(url, files=files, data=data)
    response.raise_for_status()
    print(f"图像 '{filename}' 已上传到 ComfyUI.")
    return response.json()

def queue_prompt(prompt, client_id):
    """将工作流提示排队到 ComfyUI"""
    url = f"{COMFYUI_SERVER_ADDRESS}/prompt"
    payload = {"prompt": prompt, "client_id": client_id}
    headers = {"Content-Type": "application/json"}
    response = requests.post(url, json=payload, headers=headers)
    response.raise_for_status()
    return response.json()

def get_history(prompt_id):
    """获取指定提示的执行历史和结果"""
    url = f"{COMFYUI_SERVER_ADDRESS}/history/{prompt_id}"
    response = requests.get(url)
    response.raise_for_status()
    return response.json()

def get_image(filename, subfolder, folder_type="output"):
    """从 ComfyUI 获取生成的图像"""
    url = f"{COMFYUI_SERVER_ADDRESS}/view"
    params = {"filename": filename, "subfolder": subfolder, "type": folder_type}
    response = requests.get(url, params=params)
    response.raise_for_status()
    return response.content

def process_image_with_comfyui(image_base64, client_id="your_client_id"):
    """
    处理图像的端到端函数：
    1. 将 Base64 图像转换为二进制数据
    2. 上传到 ComfyUI
    3. 触发 ComfyUI 工作流
    4. 获取处理后的图像
    5. 返回处理后的图像 Base64
    """
    try:
        # 1. 将 Base64 图像转换为二进制数据
        image_data = base64.b64decode(image_base64.split(',')) # 移除 data:image/png;base64, 前缀
        input_filename = f"input_image_{int(time.time())}.png"

        # 2. 上传到 ComfyUI
        upload_image_to_comfyui(image_data, input_filename)

        # 3. 加载并修改 ComfyUI 工作流 JSON
        workflow = load_workflow(COMFYUI_WORKFLOW_FILE)

        # 找到工作流中用于加载图像的节点（例如，LoadImage 节点）
        # 这一步需要根据实际导出的 workflow_api.json 结构来确定节点ID和class_type
        # 假设有一个 LoadImage 节点，其 class_type 为 "LoadImage"
        image_loader_node_id = None
        for node_id, node_details in workflow.items():
            if node_details.get("class_type") == "LoadImage":
                image_loader_node_id = node_id
                break

        if image_loader_node_id:
            workflow[image_loader_node_id]["inputs"]["image"] = input_filename
            print(f"工作流中 LoadImage 节点 ({image_loader_node_id}) 的输入图像已更新为: {input_filename}")
        else:
            print("警告: 未找到 LoadImage 节点，请检查您的 ComfyUI 工作流 JSON。")
            # 如果没有 LoadImage 节点，可能需要根据工作流类型调整输入方式

        # 4. 触发 ComfyUI 工作流
        prompt_response = queue_prompt(workflow, client_id)
        prompt_id = prompt_response["prompt_id"]
        print(f"工作流已排队，提示 ID: {prompt_id}")

        # 5. 轮询获取结果 (或使用 WebSocket)
        output_images =
        while True:
            history = get_history(prompt_id)
            if prompt_id in history:
                outputs = history[prompt_id].get("outputs", {})
                for node_id, node_output in outputs.items():
                    if "images" in node_output:
                        for img_info in node_output["images"]:
                            if img_info["type"] == "output": # 确保是保存的输出图像
                                output_images.append(get_image(img_info["filename"], img_info["subfolder"]))
                break
            print("等待 ComfyUI 处理完成...")
            time.sleep(2) # 每2秒轮询一次

        if not output_images:
            raise Exception("ComfyUI 未生成任何输出图像。")

        # 6. 返回处理后的图像 Base64 (假设只返回第一张图像)
        processed_image_data = output_images
        return base64.b64encode(processed_image_data).decode('utf-8')

    except requests.exceptions.RequestException as e:
        print(f"与 ComfyUI 服务器通信错误: {e}")
        return None
    except Exception as e:
        print(f"处理图像时发生错误: {e}")
        return None

# 这是一个概念性的 Python 后端 Flask 示例
# 实际部署时需要更健壮的错误处理和异步处理
from flask import Flask, request, jsonify
from flask_cors import CORS

app = Flask(__name__)
CORS(app) # 允许跨域请求

@app.route('/process-image', methods=)
def process_image_endpoint():
    data = request.json
    if not data or 'image_data_base64' not in data:
        return jsonify({"error": "缺少 image_data_base64"}), 400

    image_base64 = data['image_data_base64']
    processed_image_base64 = process_image_with_comfyui(image_base64)

    if processed_image_base64:
        return jsonify({"processed_image_base64": processed_image_base64}), 200
    else:
        return jsonify({"error": "图像处理失败"}), 500

if __name__ == '__main__':
    # 启动 Flask 服务器
    # 在生产环境中，请使用 Gunicorn 或 Waitress 等 WSGI 服务器
    app.run(host='0.0.0.0', port=5000, debug=True)
```

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

**ComfyUI 工作流 JSON 结构：**

ComfyUI 的工作流 JSON 是一个字典，其中每个键代表一个节点 ID，对应的值是一个包含 `class_type` 和 `inputs` 的字典。`inputs` 字典定义了该节点的所有输入参数。例如，`"model": ["4", 0]` 表示该节点的模型输入来自 ID 为“4”的节点的第 0 个输出 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。理解这种结构对于动态修改工作流参数以适应特定任务（如更改输入图像、调整提示词或设置种子）至关重要 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

<!---->

## V. 整体工作流程与实际考量

### 端到端工作流程

整个自动化工作流的实现涉及 Photopea、前端 JavaScript 和 Python 后端与 ComfyUI 的协同操作。首先，前端页面嵌入 Photopea `<iframe>`，并根据需要通过 URL 参数进行初始配置。一旦 Photopea 加载完成，前端通过 `postMessage` 发送 JavaScript 脚本来控制 Photopea 执行图像修改、图层操作或 PSD 内容编辑。当需要利用 ComfyUI 的 AI 能力时，Photopea 将当前图像或特定图层数据通过 `app.activeDocument.saveToOE()` 导出为 `ArrayBuffer`，并通过 `postMessage` 传递给前端。前端接收到二进制数据后，将其转换为 Base64 编码字符串，并通过 HTTP POST 请求发送到 Python 后端。Python 后端将接收到的图像上传到本地 ComfyUI 服务，并根据预定义的 `workflow_api.json` 触发相应的 AI 任务（例如，背景移除或图像扩展）。ComfyUI 处理完成后，Python 后端从 ComfyUI 获取结果图像，并将其 Base64 编码后返回给前端。最后，前端将处理后的图像数据作为 `ArrayBuffer` 通过 `postMessage` 重新导入 Photopea，作为新图层插入或替换现有图层，从而完成整个自动化循环。

### 错误处理与健壮性

在构建这种复杂的集成系统时，必须考虑全面的错误处理以确保系统的健壮性。这包括：

* **`postMessage` 通信错误：** 监听 Photopea 发送的错误消息，并确保前端脚本能够处理 Photopea 未能成功执行命令的情况。

* **ComfyUI API 错误：** Python 后端应捕获与 ComfyUI API 通信时可能发生的 HTTP 错误（例如，4xx 客户端错误，5xx 服务器错误）和网络连接问题。

* **数据格式验证：** 在数据传输的各个阶段（前端到后端，后端到 ComfyUI），验证数据的完整性和格式，以防止因数据损坏或不匹配导致的处理失败。

* **异步操作超时：** 对于涉及 Photopea 脚本执行或 ComfyUI 任务处理的异步操作，应设置合理的超时机制，以避免系统无限期等待。

### 性能优化

为了确保流畅的用户体验，性能优化是关键。

* **`ArrayBuffer` 优先：** 在 Photopea 和前端之间传输图像数据时，优先使用 `ArrayBuffer` 而非 Base64 编码字符串 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。 <!---->  <!----><!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  `ArrayBuffer` 提供了更直接的二进制数据传输，减少了编码/解码的开销，这对于大尺寸图像和 PSD 文件尤为重要，有助于保持系统的响应速度。

* **ComfyUI 资源管理：** 确保本地 ComfyUI 实例有足够的 GPU 资源来高效处理任务。对于频繁的 AI 处理请求，考虑 ComfyUI 的队列管理和并发处理能力。

* **后端数据流：** Python 后端在处理图像数据时，应优化文件读写和内存使用，避免不必要的中间文件创建。

### 安全性

安全性是任何集成系统不可忽视的方面。

* **CORS 配置：** 严格按照要求配置 `Access-Control-Allow-Origin` HTTP 头 <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->。对于本地部署环境， <!---->  <!----><!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  <!---->

  `Access-Control-Allow-Origin: *` 可以暂时放宽限制，但在生产环境中应将其限制为明确的允许源，以防止恶意跨域请求。

* **输入验证：** 在 Python 后端对所有来自前端的输入数据进行严格验证和清理，以防止注入攻击或其他恶意负载。

* **ComfyUI 访问控制：** 如果 ComfyUI 实例暴露在网络中，应考虑添加额外的身份验证或 IP 白名单，以限制未经授权的访问。

## VI. 结论与建议

本次分析揭示了 Photopea API 在自动化图像编辑和 PSD 内容操作方面的强大潜力，尤其是在与本地部署的 ComfyUI 服务集成时。Photopea 提供的与 Adobe Photoshop 高度兼容的 JavaScript 脚本环境，使其能够执行复杂的文档和图层操作。

`postMessage` API 是实现 Photopea 与外部环境之间动态、实时双向通信的关键机制。它不仅支持脚本命令的传输，还能高效地处理二进制图像数据 (`ArrayBuffer`) 的发送和接收。这种能力使得 Photopea 能够作为嵌入式模块或批处理器，由外部应用程序进行精细控制。在数据传输方面，使用 `ArrayBuffer` 而非 Base64 编码字符串对于大尺寸图像和 PSD 文件至关重要，因为它能显著减少性能开销，确保工作流的流畅性。

在本地部署环境中，正确配置 CORS 头 (`Access-Control-Allow-Origin: *`) 是建立 Photopea 与本地服务器之间可靠通信的强制性要求。未能正确设置将导致浏览器层面的安全限制，从而阻碍数据流。此外，理解 Photopea 脚本执行的异步性质，并相应地在前端实现回调或 Promise 机制，对于构建健壮且可预测的自动化序列至关重要。

**针对用户具体需求的建议：**

1. **图像修改、插入与导出：** 利用 Photopea 的 JavaScript 脚本能力，通过 `postMessage` 发送 `app.activeDocument.resizeImage()`、`app.open()`（作为智能对象插入图像）和 `app.activeDocument.saveToOE()` 等命令来实现这些操作。

2. **PSD 内容修改（图层、文字、图像替换）：** 充分利用 Photopea 对 PSD 格式的深度支持和 Photoshop 兼容脚本。通过 `app.activeDocument.layers.getByName()` 获取特定图层，然后操作其 `textItem.contents` 进行文字修改，或通过智能对象替换其内容以更新图像。

3. **使用外部插件（ComfyUI 集成）：** 采用前端 Photopea -> Python 后端 -> ComfyUI 的三层架构。前端负责从 Photopea 导出图像（通过 `saveToOE`），Python 后端作为桥梁，处理图像上传到 ComfyUI (`/upload` 端点)，触发 ComfyUI 工作流 (`/prompt` 端点)，并获取处理结果 (`/history` 和 `/view` 端点)。最后，将 ComfyUI 的输出图像传回前端，再导入 Photopea。

通过遵循本报告中概述的架构、API 使用方法和实际考量，开发者将能够构建一个强大、灵活且高效的 Photopea 自动化系统，并无缝集成 ComfyUI 的高级 AI 能力，以满足各种图像处理和生成需求。